---
title: 左右指针
date: 2023/1/29
math: true
tags:
  - 双指针
categories:
  - LeetCode题解
  - 数组
abbrlink: 509086c5
---



# 左右指针

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/ "977. 有序数组的平方")

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。



示例 1：

```纯文本
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
     排序后，数组变为 [0,1,9,16,100]

```

示例 2：

```纯文本
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]

```

提示：

-   1 <= nums.length <= $10^4$

-   $-10^4$ <= nums\[i] <= $10^4$
-   nums 已按 **非递减顺序** 排序

### 思路

#### 先平方后排序

-   时间复杂度：$O(n+n\log{n})\approx O(n\log{n})$
-   空间复杂度（不考虑返回新数组）：$O(\log{n})$的栈空间进行排序

#### 双指针

-   时间复杂度：$ O(n)  $
-   空间复杂度（不考虑返回新数组）：$ O(1)  $

因为数组本身是从小到大排序，平方后首尾指针往中间最小值递减。

所以可以使用两个指针分别为`left`，`right` ：

新平方数组的从右往左，取两个指针的最大值，然后不断更新左右指针。

```cpp
vector<int> sortedSquares(vector<int>& nums)
{
    int index = (int)nums.size();

    vector<int> newNums(index);
    int left = 0, right = index - 1;


    while (left <= right) // 左右两个指针错位，即数组遍历完
    {
        int sqrLeft = nums[left] * nums[left];
        int sqrRight = nums[right] * nums[right];

        if (sqrLeft > sqrRight)
        {
            newNums[--index] = sqrLeft;
            left++;
        }
        else
        {
            newNums[--index] = sqrRight;
            right--;
        }
    }

    return newNums;
}
```

### 源码

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> sortedSquares(vector<int>& nums);

int main()
{
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int& num: nums) cin >> num;

    vector<int> ans = sortedSquares(nums);
    for (int num: ans) cout << num << " ";
    cout << "\b\n";

    return 0;
}

vector<int> sortedSquares(vector<int>& nums)
{
    int index = (int)nums.size();

    vector<int> newNums(index);
    int left = 0, right = index - 1;

    while (left <= right)
    {
        int sqrLeft = nums[left] * nums[left];
        int sqrRight = nums[right] * nums[right];

        if (sqrLeft > sqrRight)
        {
            newNums[--index] = sqrLeft;
            left++;
        }
        else
        {
            newNums[--index] = sqrRight;
            right--;
        }
    }

    return newNums;
}
```

---
title: 回溯
math: true
mermaid: true
tags:
  - 算法题解
categories:
  - LeetCode题解
abbrlink: f92eff5d
date: '2023-02-14 17:16:08'
---

# 回溯

## 组合

### [77. 组合（Medium）](https://leetcode.cn/problems/combinations/)

组合问题的可以用以下树形结构表示

<img src="https://img.ashechol.top/picgo/combination.png" style="zoom:60%;" />

这样就很容易写出其回溯代码。

```cpp
vector<vector<int>> ans;
vector<int> path;
void dfs(int bg, int n, int k)
{
    if (path.size() == k)
    {
        ans.emplace_back(path);
        return;
    }
    
    // 对于当前剩余数量少于所需数量的情况进行剪枝
    // n - i + 1 >= k - path.size()
    for (int i = bg; i <= n - (k - path.size()) + 1; i++)
    {
        path.emplace_back(i);
        dfs(i + 1, n, k);
        path.pop_back();
    }
}

vector<vector<int>> combine(int n, int k)
{
    dfs(1, n, k);
    return ans;
}
```

**类似题目**：

* [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
* [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

### [39. 组合总和（Medium）](https://leetcode.cn/problems/combination-sum/)

因为允许重复使用元素，所以进入下一层递归就不需要缩小范围。

```cpp
vector<vector<int>> res;
vector<int> path;
int sum;

void dfs(vector<int>& nums, int bg, int target)
{
    if (sum == target)
    {
        res.emplace_back(path);
        return;
    }

    // if (sum > target) return;
    // 直接剪枝：在循环时就可以判断是否进入下层，但是需要提前排序
    for (int i = bg; i < nums.size() && sum + nums[i] <= target; i++)
    {
        path.emplace_back(nums[i]);
        sum += nums[i];
        dfs(nums, i, target);	// 下层的 bg 为 i，允许重复元素
        path.pop_back();
        sum -= nums[i];
    }
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) 
{
    sort(candidates.begin(), candidates.end());
    dfs(candidates, 0, target);
    return res;
}
```

### [40. 组合总和 II（Medium）](https://leetcode.cn/problems/combination-sum-ii/description/)

该题不能重复使用同一个元素，但是传入数组中有重复元素。为了避免出现重复的组合，首先对数组排序，然后跳过之前已经选中过的数。

```cpp
void dfs(vector<int>& nums, int bg, int target)
{
    if (sum == target)
    {
        res.emplace_back(path);
        return;
    }

    for (int i = bg; i < nums.size() && sum + nums[i] <= target; i++)
    {
        // 跳过本层已经选中过的重复元素
        if (i > bg && nums[i-1] == nums[i]) continue;

        path.emplace_back(nums[i]);
        sum += nums[i];
        dfs(nums, i+1, target);		// 缩小范围
        path.pop_back();
        sum -= nums[i];
    }
}

vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    sort(candidates.begin(), candidates.end());
    dfs(candidates, 0, target);
    return res;
}
```

## 分割

### [131. 分割回文串（Medium）](https://leetcode.cn/problems/palindrome-partitioning/)

#### 分割

<img src="https://img.ashechol.top/picgo/palindrome-partitioning.png" style="zoom: 33%;" />

如上图所示，对于每一层的各种情况实际是从字符串长度为 1 开始遍历到整个字符串的过程。每一层的开始字符是上一层的结尾字符的后一个。所以不难写出回溯代码。

```cpp
vector<vector<string>> res;
vector<string> path;

void dfs(string& s, int bg)
{
    // 已经遍历完全部字符串
    if (bg == s.size())
    {
        res.emplace_back(path);
        return;
    }


    for (int i = bg; i < s.size(); i++)
    {	
        // 取子字符串，因为substr是用的字符个数n，而且是[bg, i]，所以需要 i-bg+1
        string tmp = s.substr(bg, i - bg + 1);
        if (check(tmp))
        {
            path.emplace_back(tmp);
            dfs(s, i+1);
            path.pop_back();
        }
    }
}
```

#### 回文检测

该题另外一个重要的部分是回文字符串的判断。有很多方法可以实现。

**判断倒置后是否与原本相同**

```cpp
bool check(string s)
{
    string rs = s;
    reverse(s.begin(), s.end());
    return s == rs;
}
```

**首尾指针向内比较**

```cpp
// 对于子串
bool check(string s)
{
    for (int i = 0, j = s.size() - 1; i < j; i++, j--)
    {
        if (s[i] != s[j])
            return false;
    }
    return true;
}
// 或者通过子串下标
bool check(string s, int bg, int ed)
{
    int l = bg, r = ed;
    while (l < r)
    {
     	if (s[l++] != s[r--])
            return false;
    }
    return true;
}
```

**动态规划**

因为判断一个字符串是否回文，其实就是判断，首尾字符是否相等以及中间的子串自否是回文字符串，所以可以通过二维数组记录 [bg, ed] 的字符串是否回文。

```cpp
vector<vector<int>> record;

// 0为未初始化 1为true 2位false
int check(string s, int bg, int ed)
{
    // 重复串，直接返回
    if (record[bg][ed] != 0)
        return record[bg][ed];

    for (int i = bg, j = ed; i < j; i++, j--)
    {
        // 首尾不等或者子串不是回文
        if (s[i] != s[j] || record[i+1][j-1] == 2)
        {
            record[bg][ed] = 2;
            return 2;
        }
		// 中间子串判断
        if (record[i+1][j-1] == 1)
        {
            record[bg][ed] = 1;
            return 1;
        }
    }
    record[bg][ed] = 1;
    return 1;
}

void dfs(string& s, int bg, vector<vector<string>>& res, vector<string>& path)
{
    if (bg == s.size())
    {
        res.emplace_back(path);
        return;
    }

    for (int i = bg; i < s.size(); i++)
    {
        if (check(s, bg, i) == 1)
        {
            path.emplace_back(s.substr(bg, i-bg+1));
            dfs(s, i+1, res, path);
            path.pop_back();
        }
    }
}

vector<vector<string>> partition(string s) 
{
    record.resize(s.size(),vector<int>(s.size(), 0));
    vector<vector<string>> res;
    vector<string> path;
    dfs(s, 0, res, path);
    return res;
}
```

### [93. 复原 IP 地址（Medium）](https://leetcode.cn/problems/restore-ip-addresses/)

本体主要难点在于有很多种无效 IP 地址的情况需要分析：

* 遍历完字符串没有 4 个整数
* 有四个整数时没有遍历完字符串
* 整数大于 255
* 整数是有 0 开头

考虑到以上 4 点后，就可以写出正确的回溯

> 题目确保了不会有数字外的其他字符，所以不用考虑字符是否为数字

```cpp
int cnt;
void dfs(const string& s, int bg, vector<string>&res, string path)
{
    // 遍历完字符串且有 4 个整数是正确答案
    if (bg == s.size() && cnt == 4)
    {
        path.pop_back();		// 删除多余的 '.'
        res.emplace_back(path);
        return;
    }
	// 剪枝：有四个整数时没有遍历完字符串
    if (cnt == 4 && bg < s.size())
        return;
	
    // 剪枝：每层最多往后遍历三个字符
    for (int i = bg; i < s.size() && i < bg + 3; i++)
    {
        string tmp = s.substr(bg, i-bg+1);
		
        // 剪枝：无效整数
        if (stoi(tmp) > 255 || (s[bg] == '0' && i > bg)) return;

        cnt++;
        dfs(s, i+1, res, path+tmp+'.'); // 直接把 path 放入形参回溯
        cnt--;
    }
}

vector<string> restoreIpAddresses(const string& s)
{
    vector<string> res;
    // 字符超过 12 个或者小于 4个 肯定不可能有正解
    if (s.size() > 12 || s.size() < 4) return res;

    dfs(s, 0, res, "");
    return res;
}
```

## 子集

### [78. 子集（Medium）](https://leetcode.cn/problems/subsets/)

<img src="https://img.ashechol.top/picgo/subset.png" style="zoom:38%;" />

如上图，分析画出回溯树后不难通过代码实现。

子集和组合分割不同的地方在于，在终止判断前存入 path，否则会在终止时漏掉最后一个子集。

```cpp
void dfs(vector<int>& nums, int bg, vector<vector<int>>& res, vector<int>& path)
{
    res.emplace_back(path);

    if (bg == nums.size())
        return;

    for (int i = bg; i < nums.size(); i++)
    {
        path.emplace_back(nums[i]);
        dfs(nums, i+1, res, path);
        path.pop_back();
    }
}

vector<vector<int>> subsets(vector<int>& nums) 
{
    vector<vector<int>> res;
    vector<int> path;
    dfs(nums, 0, res, path);
    return res;
}
```

### [90. 子集 II（Medium）](https://leetcode.cn/problems/subsets-ii/description/)

<img src="https://img.ashechol.top/picgo/subset_ii.png" style="zoom:38%;" />

本体和 **78. 子集** 的不同之处是要排除重复的子集，比如，[1, 第一个2] 和 [1, 第二个2]。

从上图分析可以知道，判断是否重复实际是在递归的每层判断是否有重复的值。为此我们可以先讲输入排序，然后用 i 和 i - 1 对应的数来判断是否重复

```cpp
void dfs(vector<int>& nums, int bg, vector<vector<int>>& res, vector<int>& path)
{
    res.emplace_back(path);

    if (bg == nums.size())
        return;

    for (int i = bg; i < nums.size(); i++)
    {
        // 和上一个相同，跳过
        if (i > bg && nums[i] == nums[i-1])
            continue;

        path.emplace_back(nums[i]);                
        dfs(nums, i+1, res, path);
        path.pop_back();
    }
}

vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    vector<int> path;
    dfs(nums, 0, res, path);
    return res;
}
```


---
title: 回溯
math: true
mermaid: true
tags:
  - 算法题解
categories:
  - LeetCode题解
abbrlink: f92eff5d
date: '2023-02-14 17:16:08'
---

# 回溯

## 组合

### [77. 组合](https://leetcode.cn/problems/combinations/)

组合问题的可以用以下树形结构表示

<img src="https://img.ashechol.top/picgo/combination.png" style="zoom:60%;" />

这样就很容易写出其回溯代码。

```cpp
vector<vector<int>> ans;
vector<int> path;
void dfs(int bg, int n, int k)
{
    if (path.size() == k)
    {
        ans.emplace_back(path);
        return;
    }
    
    // 对于当前剩余数量少于所需数量的情况进行剪枝
    // n - i + 1 >= k - path.size()
    for (int i = bg; i <= n - (k - path.size()) + 1; i++)
    {
        path.emplace_back(i);
        dfs(i + 1, n, k);
        path.pop_back();
    }
}

vector<vector<int>> combine(int n, int k)
{
    dfs(1, n, k);
    return ans;
}
```

**类似题目**：

* [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
* [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

### [39. 组合总和（Medium）](https://leetcode.cn/problems/combination-sum/)

因为允许重复使用元素，所以进入下一层递归就不需要缩小范围。

```cpp
vector<vector<int>> res;
vector<int> path;
int sum;

void dfs(vector<int>& nums, int bg, int target)
{
    if (sum == target)
    {
        res.emplace_back(path);
        return;
    }

    // if (sum > target) return;
    // 直接剪枝：在循环时就可以判断是否进入下层，但是需要提前排序
    for (int i = bg; i < nums.size() && sum + nums[i] <= target; i++)
    {
        path.emplace_back(nums[i]);
        sum += nums[i];
        dfs(nums, i, target);	// 下层的 bg 为 i，允许重复元素
        path.pop_back();
        sum -= nums[i];
    }
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) 
{
    sort(candidates.begin(), candidates.end());
    dfs(candidates, 0, target);
    return res;
}
```

### [40. 组合总和 II（Medium）](https://leetcode.cn/problems/combination-sum-ii/description/)

该题不能重复使用同一个元素，但是传入数组中有重复元素。为了避免出现重复的组合，首先对数组排序，然后跳过之前已经选中过的数。

```cpp
void dfs(vector<int>& nums, int bg, int target)
{
    if (sum == target)
    {
        res.emplace_back(path);
        return;
    }

    for (int i = bg; i < nums.size() && sum + nums[i] <= target; i++)
    {
        // 跳过本层已经选中过的重复元素
        if (i > bg && nums[i-1] == nums[i]) continue;

        path.emplace_back(nums[i]);
        sum += nums[i];
        dfs(nums, i+1, target);		// 缩小范围
        path.pop_back();
        sum -= nums[i];
    }
}

vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    sort(candidates.begin(), candidates.end());
    dfs(candidates, 0, target);
    return res;
}
```

## 分割



```cpp
vector<vector<string>> res;
vector<string> path;

bool check(string s)
{
    for (int i = 0, j = s.size() - 1; i < j; i++, j--)
    {
        if (s[i] != s[j])
            return false;
    }
    return true;
}

void dfs(string& s, int bg)
{
    if (bg == s.size())
    {
        res.emplace_back(path);
        return;
    }


    for (int i = bg; i < s.size(); i++)
    {
        string tmp = s.substr(bg, i - bg + 1);
        if (check(tmp))
        {
            path.emplace_back(tmp);
            dfs(s, i+1);
            path.pop_back();
        }
    }
}

vector<vector<string>> partition(string s) {
    dfs(s, 0);
    return res;
}
```





```cpp
vector<vector<string>> res;
vector<string> path;
vector<vector<int>> record;

int check(string s, int bg, int ed)
{
    if (record[bg][ed] != 0)
        return record[bg][ed];

    for (int i = bg, j = ed; i < j; i++, j--)
    {
        if (s[i] != s[j])
        {
            record[bg][ed] = 2;
            return 2;
        }

        if (s[i] == s[j] && record[i+1][j-1] == 1)
        {
            record[bg][ed] = 1;
            return 1;
        }
    }
    record[bg][ed] = 1;
    return 1;
}

void dfs(string& s, int bg)
{
    if (bg == s.size())
    {
        res.emplace_back(path);
        return;
    }

    for (int i = bg; i < s.size(); i++)
    {
        if (check(s, bg, i) == 1)
        {
            path.emplace_back(s.substr(bg, i-bg+1));
            dfs(s, i+1);
            path.pop_back();
        }
    }
}

vector<vector<string>> partition(string s) 
{
    record.resize(s.size(),vector<int>(s.size(), 0));
    dfs(s, 0);
    return res;
}
```


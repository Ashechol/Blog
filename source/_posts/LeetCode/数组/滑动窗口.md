---
title: 滑动窗口
date: 2023/1/29
math: true
tags:
- 双指针
- 滑动窗口
categories:
- LeetCode题解
- 数组
---



# 滑动窗口

## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/ "209. 长度最小的子数组")

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 \[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。



示例 1：

```纯文本
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

```

示例 2：

```纯文本
输入：target = 4, nums = [1,4,4]
输出：1

```

示例 3：

```纯文本
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
```

提示：

-   1 <= target <= $10^9$
-   1 <= nums.length <= $10^5$
-   1 <= nums\[i] <= $10^5$
    &#x20;

进阶：

如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。

### 思路

#### 队列

-   时间复杂度：$O(n)$
-   空间复杂度：$ O(n)  $

<img src="https://img.ashechol.top/algorithm/minimum-size-subarray-sum.png" style="zoom:45%;" />

```c++
int minSubArrayLen_que(int target, vector<int>& nums)
{
    queue<int> que;
        int sum = 0;
        int minLen = INT32_MAX;
        
        for (int& num: nums)
        {
            sum += num;
            que.push(num);

            while (sum >= target)
            {
                if (minLen > que.size()) minLen = (int) que.size();

                sum -= que.front();
                que.pop();
            }
        }

        return minLen == INT32_MAX ? 0 : minLen;
}
```

#### 滑动窗口

-   时间复杂度：$O(n)$
-   空间复杂度：$ O(1)
      $

![](https://img.ashechol.top/algorithm/minimum-size-subarray-sum.gif)

```c++
int minSubArrayLen(int target, vector<int>& nums)
{
    int sum = 0;
    int minLen = INT32_MAX;

    for (int l = 0, r = 0; r < nums.size(); r++)
    {
        sum += nums[r];

        while (sum >= target)
        {
            // r - l + 1 因为 [l, r]
            if (minLen > r - l + 1) minLen = r - l + 1;

            sum -= nums[l++];
        }
    }
    
    // 另外一种循环写法
    // for (int l = 0, r = 0; r < nums.size() || sum >= target;)
    // {
    //     if (sum >= target)
    //     {
               // [l, r)
    //         if (minLen > r - l) minLen = r - l;
    //
    //         sum -= nums[l++];
    //     }
    //     else if (r < nums.size())
    //         sum += nums[r++];
    // }

    return minLen == INT32_MAX ? 0 : minLen;
}
```

### 源码

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int minSubArrayLen(int target, vector<int>& nums);

int main()
{
    int n, target;

    cin >> n >> target;

    vector<int> nums(n);

    for (int& num: nums) cin >> num;

    cout << minSubArrayLen(target, nums);

    return 0;
}

int minSubArrayLen_que(int target, vector<int>& nums)
{
    queue<int> que;
    int sum = 0;
    int minLen = INT32_MAX;

    for (int& num: nums)
    {
        sum += num;
        que.push(num);

        while (sum >= target)
        {
            if (minLen > que.size()) minLen = (int) que.size();

            sum -= que.front();
            que.pop();
        }
    }

    return minLen == INT32_MAX ? 0 : minLen;
}

int minSubArrayLen(int target, vector<int>& nums)
{
    int sum = 0;
    int minLen = INT32_MAX;

    for (int l = 0, r = 0; r < nums.size(); r++)
    {
        sum += nums[r];

        while (sum >= target)
        {
            if (minLen > r - l + 1) minLen = r - l + 1;

            sum -= nums[l++];
        }
    }

    return minLen == INT32_MAX ? 0 : minLen;
}

```

## [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/ "904. 水果成篮")

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits\[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。



示例 1：

```纯文本
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。

```

示例 2：

```纯文本
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。

```

示例 3：

```纯文本
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。

```

示例 4：

```纯文本
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
 
```

提示：

-   1 <= fruits.length <= $10^5$
-   0 <= fruits\[i] < fruits.length

### 思路

题目实际是求一个数组中，有最多两种不同值的最大连续子数组。所以可以使用滑动窗口来解决。

需要注意的是滑动窗口左边界的更新方式，比如：

```纯文本
1 2 1 2 2 2 3 3
其中 2 3 交界，左边界应该从 0 更新到 3，而不是 1 或者 5
```

#### 滑动窗口 + 向左更新左边界

-   时间复杂度：$O(m+n)\approx O(n),\; m<n$
-   空间复杂度：$O(1)$

```c++
int totalFruit(vector<int>& fruits)
{
    int maxTotal = 0;
    // 当前子数组中水果种类，有先后顺序
    int fruitTypes[] = {-1, -1};

    if (fruits.size() <= 2) return (int) fruits.size();

    for (int l = 0, r = 0; r < fruits.size(); r++)
    {
        // 没有水果则加入
        if (fruitTypes[0] == -1)
            fruitTypes[0] = fruits[r];
        else if (fruitTypes[1] == -1 && fruitTypes[0] != fruits[r])
            fruitTypes[1] = fruits[r];
        // 有新的种类水果
        else if (fruitTypes[0] != fruits[r] && fruitTypes[1] != fruits[r])
        {
            // 有新的水果，则一定是交界，符合下面的规则
            fruitTypes[0] = fruits[r - 1];
            fruitTypes[1] = fruits[r];
            
            // 向左更新左边界，找到最大连续，种类为fruitType[0]的水果
            l = r;
            while (fruits[l - 1] == fruitTypes[0]) l--;
        }

        if (maxTotal < r - l + 1) maxTotal = r - l + 1;
    }

    return maxTotal;
}
```

#### 滑动窗口+哈希表（unordered\_map）/字典（map）

-   时间复杂度：$O(m+n)\approx O(n),\; m < n$
-   空间复杂度：$ O(n)
      $

使用一个哈希表或者字典，记录子数组水果种类和其数量。

当水果种类超过两种，则开始更新左边界：

-   不断减去左边界对应水果的数量，并让左边界向右移动。
-   当左边界对应的水果数量减少为0，则表示已经找到最新的左边界了

```c++
int totalFruit_Hashmap(vector<int>& fruits)
{
    int maxTotal = 0;
    unordered_map<int, int> fruitTypeNum;

    for (int l = 0, r = 0; r < fruits.size(); r++)
    {
        fruitTypeNum[fruits[r]]++;
        
        // 子数组水果种类超过2
        while (fruitTypeNum.size() > 2)
        {
            // 左指针对应水果种类的数量减少
            fruitTypeNum[fruits[l]]--;

            if (fruitTypeNum[fruits[l]] == 0)
                fruitTypeNum.erase(fruits[l]);
            
            // 左指针向右移动
            l++;
        }

        maxTotal = max(maxTotal, r - l + 1);
    }

    return maxTotal;
}
```

### 源码

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int totalFruit(vector<int>& fruits);

int main()
{
    int n;
    cin >> n;

    vector<int> fruits(n);
    for (int& fruit: fruits) cin >> fruit;

    cout << totalFruit(fruits) << endl;

    return 0;
}

int totalFruit(vector<int>& fruits)
{
    int maxTotal = 0;
    int fruitTypes[] = {-1, -1};

    if (fruits.size() <= 2) return (int) fruits.size();

    for (int l = 0, r = 0; r < fruits.size(); r++)
    {
        if (fruitTypes[0] == -1)
            fruitTypes[0] = fruits[r];

        else if (fruitTypes[1] == -1 && fruitTypes[0] != fruits[r])
            fruitTypes[1] = fruits[r];

        else if (fruitTypes[0] != fruits[r] && fruitTypes[1] != fruits[r])
        {
            fruitTypes[0] = fruits[r - 1];
            fruitTypes[1] = fruits[r];

            l = r;
            while (fruits[l - 1] == fruitTypes[0]) l--;
        }

        if (maxTotal < r - l + 1) maxTotal = r - l + 1;
    }

    return maxTotal;
}

int totalFruit_Hashmap(vector<int>& fruits)
{
    int maxTotal = 0;
    unordered_map<int, int> fruitTypeNum;

    for (int l = 0, r = 0; r < fruits.size(); r++)
    {
        fruitTypeNum[fruits[r]]++;

        while (fruitTypeNum.size() > 2)
        {
            fruitTypeNum[fruits[l]]--;

            if (fruitTypeNum[fruits[l]] == 0)
                fruitTypeNum.erase(fruits[l]);

            l++;
        }

        maxTotal = max(maxTotal, r - l + 1);
    }

    return maxTotal;
}



```

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/ "76. 最小覆盖子串")

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。



注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

```纯文本
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

```

示例 2：

```纯文本
输入：s = "a", t = "a"
输出："a"

```

示例 3:

```纯文本
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。

```

提示：

-   1 <= s.length, t.length <= $10^5$
-   s 和 t 由英文字母组成

进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？

### 思路

#### 滑动窗口+哈希表

-   时间复杂度：$O(m+n)\approx O(n),\; m<n$
-   空间复杂度：$O(n)$

**方法一**

1.  首先，因为要对字符串中的各个字符的数量进行数量的比较，所以使用两个哈希表进行记录。
2.  右指针遍历字符串的同时，更新哈希表中字符数量。
3.  使用变量`typeNum` 对满足条件的字符种类进行统计。
4.  当`typeNum` 大小为字符串`t` 哈希表的大小时，说明找到一个覆盖子串。
5.  比较长度，如果是最小子串则更新结果。
6.  开始对左边界更新，直到不满足覆盖条件。

```c++
string minSubString(string s, string t)
{
    unordered_map<char, int> sCharCnt, tCharCnt;
    int minLen = INT32_MAX;
    string res;

    for (const char c: t) tCharCnt[c]++;

    int typeNum = 0;

    for (int l = 0, r = 0; r < s.size(); r++)
    {
        sCharCnt[s[r]]++;
        
        // 当前字符属于t，切数量等于t中的数量
        if (tCharCnt.find(s[r]) != tCharCnt.end() && sCharCnt[s[r]] == tCharCnt[s[r]])
            typeNum++;
        
        // 已满足覆盖条件
        while (typeNum == tCharCnt.size())
        {
            // 更新结果
            if (minLen > r - l + 1)
            {
                minLen   = r - l + 1;
                res = s.substr(l, r - l + 1);
            }
            
            // 左边界对应字符数量不等于t中的数量时，退出循环
            if (tCharCnt.find(s[l]) != tCharCnt.end() && --sCharCnt[s[l]] < tCharCnt[s[l]] )
                typeNum--;
            // 向右更新左边界
            l++;
        }
    }

    return res;
}
```

**更为简洁的一种方法**

```c++
string minSubString_abbr(string s, string t)
{
    unordered_map<char, int> sCharCnt, tCharCnt;
    string res;
    
    for (char c: t) tCharCnt[c]++;

    for (int l = 0, r = 0, cnt = 0; r < s.size(); r++)
    {
        sCharCnt[s[r]]++;
        
        // 更新为t中字符的总量
        if (sCharCnt[s[r]] <= tCharCnt[s[r]]) cnt++;
        
        // 向右更新左边界
        while (sCharCnt[s[l]] > tCharCnt[s[l]]) sCharCnt[s[l++]]--;
        
        // cnt == t.length 说明找到一个覆盖子串
        // 结果为空或者结果长度大于当前子串，则更新结果
        if (cnt == t.length() && (res.empty() || res.length() > r - l + 1))
            res = s.substr(l, r - l + 1);
    }

    return res;
}
```

这个方法的妙处就是，不去考虑种类的数量。而是统计`s`子串中，属于`t`的数量。

由于stl哈希表的特点：`tCharCnt[s[r]]` 如果`tCharCnt` 中没有键值为`s[r]` 的变量，

会创建一个`{s[r], 0}` 。

因此`sCharCnt[s[r]] <= tCharCnt[s[r]]` 仍然可以筛选掉不属于tCharCnt的键。

`sCharCnt[s[l]] > tCharCnt[s[l]]` 同理。

### 源码

```c++
#include <iostream>
#include <unordered_map>

using namespace std;

string minSubString(string s, string t);

int main()
{
    string s, t;

    cin >> s >> t;

    cout << minSubString(s, t) << endl;

    return 0;
}

string minSubString(string s, string t)
{
    unordered_map<char, int> sCharCnt, tCharCnt;
    int minLen = INT32_MAX;
    string res;

    for (const char c: t) tCharCnt[c]++;

    int typeNum = 0;

    for (int l = 0, r = 0; r < s.size(); r++)
    {
        sCharCnt[s[r]]++;

        // 当前字符属于t，切数量等于t中的数量
        if (tCharCnt.find(s[r]) != tCharCnt.end() && sCharCnt[s[r]] == tCharCnt[s[r]])
            typeNum++;

        // 已满足覆盖条件
        while (typeNum == tCharCnt.size())
        {
            // 更新结果
            if (minLen > r - l + 1)
            {
                minLen   = r - l + 1;
                res = s.substr(l, r - l + 1);
            }

            // 向右更新左边界
            sCharCnt[s[l]]--;

            // 左边界对应字符数量不等于t中的数量时，退出循环
            if (tCharCnt.find(s[l]) != tCharCnt.end() && sCharCnt[s[l]] < tCharCnt[s[l]] )
                typeNum--;
            // 向右更新左边界
            l++;
        }
    }

    return res;
}

string minSubString_abbr(string s, string t)
{
    unordered_map<char, int> sCharCnt, tCharCnt;
    string res;

    for (char c: t) tCharCnt[c]++;

    for (int l = 0, r = 0, cnt = 0; r < s.size(); r++)
    {
        sCharCnt[s[r]]++;

        if (sCharCnt[s[r]] <= tCharCnt[s[r]]) cnt++;

        while (sCharCnt[s[l]] > tCharCnt[s[l]]) sCharCnt[s[l++]]--;

        if (cnt == t.length() && (res.empty() || res.length() > r - l + 1))
            res = s.substr(l, r - l + 1);
    }

    return res;
}

```


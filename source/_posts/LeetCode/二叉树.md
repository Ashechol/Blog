---
title: 二叉树
math: true
mermaid: true
tags:
  - 算法题解
categories:
  - LeetCode题解
abbrlink: e85d694a
date: 2023-02-02 18:20:37
---

# 二叉树

## 二叉树遍历

### [199. 二叉树的右视图（Medium）](https://leetcode.cn/problems/binary-tree-right-side-view/)

#### 广度优先

层序遍历找最右结点

```cpp
vector<int> rightSideView(TreeNode* root)
{
    vector<int> res;
    queue<TreeNode*> que;
    if (root) que.push(root); // 空指针判定很重要！！！！！！！！！！

    while (!que.empty())
    {
        TreeNode* cur;
        int size = que.size();
        int last = 0;

        while (size--)
        {
            cur = que.front();
            last = cur->val;
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
            que.pop();
        }

        res.push_back(last);
    }

    return res;
}
```

#### 深度优先

每层先访问右节点，记录每层遇到的第一个节点即为最右结点。

```cpp
void dfs(TreeNode* cur, vector<int>& res, int depth)
{
    if (!cur) return;

    if (res.size() == depth) res.emplace_back(cur->val);

    dfs(cur->right, res, depth + 1);
    dfs(cur->left, res, depth + 1);
}
```

#### 类似题目

[637. 二叉树的层平均值（Easy）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

### [515. 在每个树行中找最大值（Medium）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

#### 深度优先

```cpp
void dfs(vector<int>& res, TreeNode* cur, int depth)
{
    if (!cur) return;

    if (res.size() == depth)
        res.emplace_back(cur->val);
    else
        res[depth] = max(cur->val, res[depth]);

    dfs(res, cur->left, depth + 1);
    dfs(res, cur->right, depth + 1);
}
```

#### 广度优先

```cpp
vector<int> bfs(TreeNode* root)
{
    vector<int> res;
    queue<TreeNode*> que;

    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();
        int m = INT_MIN;
        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (cur->val > m) m = cur->val;

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        res.push_back(m);
    }

    return res;
}
```

### [104. 二叉树的最大深度（Easy）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### 深度优先

```cpp
void dfs(TreeNode* cur, int& res, int depth)
{
    if (!cur) return;

    res = max(res, depth)

    dfs(cur->left, res, depth + 1);
    dfs(cur->right, res, depth + 1);
}

int maxDepth(TreeNode* root)
{
    int res = 0;
    dfs(root, res, 1);
    return res;
}
```

#### 广度优先

```cpp
int bfs(TreeNode* root)
{
    int res = 0;
    queue<TreeNode*> que;

    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();

        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        res++;
    }

    return res;
}
```

### [111. 二叉树的最小深度（Easy）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

最小深度即为第一次遇到节点左右孩子都为空。

#### 深度优先

```cpp
// dfs(root, res, 1);
void dfs(TreeNode* cur, int& res, int depth)
{
    if (!cur)
    {
        res = min(depth, res);
        return;
    }

    if (!cur->left && !cur->right)
        res = min(depth, res);

    dfs(cur->left, res, depth + 1);
    dfs(cur->right, res, depth + 1);
}
```

#### 广度优先

```cpp
int bfs(TreeNode* root)
{
    int res = 0;
    queue<TreeNode*> que;
    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();
        res++;
        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (!cur->left && !cur->right)
                return res;

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
    }

    return res;
}
```

### [116. 填充每个节点的下一个右侧节点指针（Medium）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

#### 层序连接

```cpp
Node* connect(Node* root)
{
    queue<Node*> que;
    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();

        for (int i = 0; i < size; i++)
        {
            Node* cur = que.front();
            que.pop();
			
            // 每层最后一个结点不连接
            if (i < size - 1)
                cur->next = que.front();

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
    }

    return root;
}
```

因为需要额外的队列空间来维护结点，所以空间复杂度为 $O(n)$

#### 依靠 next 指针遍历

每层都提前将下层的结点向右连接起来，之后到下一层只需通过 next 遍历，不需要额外的队列空间。空间复杂度 $O(1)$

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* level = root;

    while (level)
    {
        Node* cur = level;
        while (cur)
        {
            // 左子结点指向右子结点
            cur->left->next = cur->right;
            // 右子结点指向邻近兄弟节点
            if (cur->next)
            	cur->right->next = cur->next->left;

            cur = cur->next;
        }

        level = level->left;
    }
    return root;
}
```

### [117. 填充每个节点的下一个右侧节点指针 II（Medium）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

这道题是 116 的进阶版，树不再是 **完美/满二叉树** 。对于广度优先来说和 116 没有任何区别，不过想要做到空间复杂度为 $O(1)$ ，处理方法和 116 还是有些许不同。

#### 麻烦办法：不引入 dummy 结点

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* level = root;

    while (level)
    {
        Node* cur = level;
        Node* pre = nullptr;
        // 为下层连接 next
        while (cur)
        {
            if (cur->left)
            {
                // 如果 pre 不为空，说明存在上一个需要连接的结点
                if (pre) pre->next = cur->left;
                pre = cur->left;
            }
            if (cur->right)
            {
                if (pre) pre->next = cur->right;
                pre = cur->right;
            }

            cur = cur->next;
        }
		
        // 寻找下层起始结点
        while (level)
        {
            if (level->left)
            {
                level = level->left;
                break;
            }

            if (level->right)
            {
                level = level->right;
                break;
            }
			
            // 当前结点左右为空，则寻找 next 的左右结点
            level = level->next;
        }
    }

    return root;
}
```

#### 引入 dummy 结点

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* cur = root;
    Node* dummy = new Node(0);

    while (cur)
    {
        // dummy 每层开始必须置为空防止无限循环最后一层
        dummy->next = nullptr;
        Node* pre = dummy;

        while (cur)
        {
            if (cur->left)
            {
                pre->next = cur->left;
                pre = pre->next;
            }
            if (cur->right)
            {
                pre->next = cur->right;
                pre = pre->next;
            }

            cur = cur->next;
        }

        cur = dummy->next;
    }

    return root;
}
```

## 两颗树同时遍历

100、101、572 这三道题是层层递进的关系。

```mermaid
graph LR
A("100.相同的树")--"判定条件变化后"---B("101.对称二叉树")
A--"运用于"-->C("572.另一棵树的子树")
```

### [100. 相同的树（Easy）](https://leetcode.cn/problems/same-tree/)

该题需要对传入的两颗树的每个节点比较是否相等。所以需要同时遍历两颗树。然后比较两颗树的左右子结点。

#### 递归法

```cpp
bool isSame(TreeNode* a, TreeNode* b)
{
    // 两个节点都为空，自然相同
    if (!a && !b) return true;
    // 其一为空，则说明不相同
    if (!a || !b) return false;
    // 值不相等，则说明不同
    if (a->val != b->val) return false;
	
    // 左相同 && 右相同
    return isSame(a->left, b->left) && isSame(a->right, b->right);
}
```

#### 迭代法

```cpp
bool isSameIteration(TreeNode* a, TreeNode* b)
{
    queue<TreeNode*> que;
    que.push(a);
    que.push(b);
    
    while (!que.empty())
    {
        TreeNode* curA = que.front(); que.pop();
        TreeNode* curB = que.front(); que.pop();
        
        if (!curA && !curB) continue;
        if (!curA || !curB) return false;
        if (curA->val != curB->val) return false;
        
        que.push(curA->left);
        que.push(curB->left);
        que.push(curA->right);
        que.push(curB->right);
    }
    
    return true;
}
```

### [101. 对称二叉树（Easy）](https://leetcode.cn/problems/symmetric-tree/)

要判断一棵树是否轴对称，需要从外到内（内到外）判断两颗子树是否对称。即判断：

* left->left 和 right->right
* left->right 和 right->left

以下几种情况则说明不对称：

* 两者之一为空
* 两者值不相等
* 两者的子树不对称

换句话说，满足以下条件则说明对称：

* 两者都为空
* 两者值相等 且 两者的子树对称

#### 递归法

```cpp
bool compare(TreeNode* left, TreeNode* right)
{
    if (!left && !right) return true;
    if (!left || !right) return false;

    bool outside = compare(left->left, right->right);
    bool inside = compare(left->right, right->left);
	
    // 值 && 外 && 内
    return left->val == right->val && outside && inside;
}
```

#### 迭代法

```cpp
bool compareIteration(TreeNode* root)
{
    queue<TreeNode*> que;

    que.push(root->left);
    que.push(root->right);

    while (!que.empty())
    {
        TreeNode* left = que.front();
        que.pop();
        TreeNode* right = que.front();
        que.pop();

        if (!left && !right) continue;
        if (!left || !right) return false;
        if (left->val != right->val) return false;

        que.push(left->left);
        que.push(right->right);
        que.push(left->right);
        que.push(right->left);
    }

    return true;
}
```

### [572. 另一棵树的子树（Easy）](https://leetcode.cn/problems/subtree-of-another-tree/)

改题需要我们在一棵树中寻找是否存在与目标相同的子树。这与 [100. 相同的树](#相同的树easy) 的不同之处主要在于，进行比较的两棵树其中之一变为了一棵树的子树。

因此我们需要先确定子树的根节点，如果这课子树不满足，则需要找到下一颗子树进行比较。所以这个问题涉及到了两次递归（或多层迭代循环）。

#### 递归法

**子树是否相同判断**

这里与 [100. 相同的树](#相同的树easy) 并无差异。

```cpp
bool isSameTree(TreeNode* cur, TreeNode* subCur)
{
    if (!cur && !subCur) return true;
    if (!cur || !subCur) return false;
    if (cur->val != subCur->val) return false;

    return isSameTree(cur->left, subCur->left) && isSameTree(cur->right, subCur->right);
}
```

**遍历树种的子树**

```cpp
bool isSubtree(TreeNode* cur, TreeNode* subRoot)
{
    if (!cur) return false;
    // 判断以该结点为根的子树是否与目标相同
    if (isSameTree(cur, subRoot)) return true;
	
    // 继续向下寻找左子树和右子树
    return isSubtree(cur->left, subRoot) || isSubtree(cur->right, subRoot);
}
```


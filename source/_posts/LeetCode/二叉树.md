---
title: 二叉树
math: true
tags:
  - 算法题解
categories:
  - LeetCode题解
abbrlink: e85d694a
date: 2023-02-02 18:20:37
---

# 二叉树

## 二叉树遍历

### [199. 二叉树的右视图（Medium）](https://leetcode.cn/problems/binary-tree-right-side-view/)

#### 广度优先

层序遍历找最右结点

```cpp
vector<int> rightSideView(TreeNode* root)
{
    vector<int> res;
    queue<TreeNode*> que;
    if (root) que.push(root); // 空指针判定很重要！！！！！！！！！！

    while (!que.empty())
    {
        TreeNode* cur;
        int size = que.size();
        int last = 0;

        while (size--)
        {
            cur = que.front();
            last = cur->val;
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
            que.pop();
        }

        res.push_back(last);
    }

    return res;
}
```

#### 深度优先

每层先访问右节点，记录每层遇到的第一个节点即为最右结点。

```cpp
void dfs(TreeNode* cur, vector<int>& res, int depth)
{
    if (!cur) return;

    if (res.size() == depth) res.emplace_back(cur->val);

    dfs(cur->right, res, depth + 1);
    dfs(cur->left, res, depth + 1);
}
```

**类似题目**

[637. 二叉树的层平均值（Easy）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

### [515. 在每个树行中找最大值（Medium）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

#### 深度优先

```cpp
void dfs(vector<int>& res, TreeNode* cur, int depth)
{
    if (!cur) return;

    if (res.size() == depth)
        res.emplace_back(cur->val);
    else
        res[depth] = max(cur->val, res[depth]);

    dfs(res, cur->left, depth + 1);
    dfs(res, cur->right, depth + 1);
}
```

#### 广度优先

```cpp
vector<int> bfs(TreeNode* root)
{
    vector<int> res;
    queue<TreeNode*> que;

    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();
        int m = INT_MIN;
        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (cur->val > m) m = cur->val;

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        res.push_back(m);
    }

    return res;
}
```

### [104. 二叉树的最大深度（Easy）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### 深度优先

```cpp
void dfs(TreeNode* cur, int& res, int depth)
{
    if (!cur) return;

    res = max(res, depth)

    dfs(cur->left, res, depth + 1);
    dfs(cur->right, res, depth + 1);
}

int maxDepth(TreeNode* root)
{
    int res = 0;
    dfs(root, res, 1);
    return res;
}
```

#### 广度优先

```cpp
int bfs(TreeNode* root)
{
    int res = 0;
    queue<TreeNode*> que;

    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();

        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        res++;
    }

    return res;
}
```

### [111. 二叉树的最小深度（Easy）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

最小深度即为第一次遇到节点左右孩子都为空。

#### 深度优先

```cpp
// dfs(root, res, 1);
void dfs(TreeNode* cur, int& res, int depth)
{
    if (!cur)
    {
        res = min(depth, res);
        return;
    }

    if (!cur->left && !cur->right)
        res = min(depth, res);

    dfs(cur->left, res, depth + 1);
    dfs(cur->right, res, depth + 1);
}
```

#### 广度优先

```cpp
int bfs(TreeNode* root)
{
    int res = 0;
    queue<TreeNode*> que;
    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();
        res++;
        while (size--)
        {
            TreeNode* cur = que.front();
            que.pop();
            if (!cur->left && !cur->right)
                return res;

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
    }

    return res;
}
```

### [116. 填充每个节点的下一个右侧节点指针（Medium）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

#### 层序连接

```cpp
Node* connect(Node* root)
{
    queue<Node*> que;
    if (root) que.push(root);

    while (!que.empty())
    {
        int size = que.size();

        for (int i = 0; i < size; i++)
        {
            Node* cur = que.front();
            que.pop();
			
            // 每层最后一个结点不连接
            if (i < size - 1)
                cur->next = que.front();

            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
    }

    return root;
}
```

因为需要额外的队列空间来维护结点，所以空间复杂度为 $O(n)$

#### 依靠 next 指针遍历

每层都提前将下层的结点向右连接起来，之后到下一层只需通过 next 遍历，不需要额外的队列空间。空间复杂度 $O(1)$

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* level = root;

    while (level)
    {
        Node* cur = level;
        while (cur)
        {
            // 左子结点指向右子结点
            cur->left->next = cur->right;
            // 右子结点指向邻近兄弟节点
            if (cur->next)
            	cur->right->next = cur->next->left;

            cur = cur->next;
        }

        level = level->left;
    }
    return root;
}
```

### [117. 填充每个节点的下一个右侧节点指针 II（Medium）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

这道题是 116 的进阶版，树不再是 **完美/满二叉树** 。对于广度优先来说和 116 没有任何区别，不过想要做到空间复杂度为 $O(1)$ ，处理方法和 116 还是有些许不同。

#### 麻烦办法：不引入 dummy 结点

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* level = root;

    while (level)
    {
        Node* cur = level;
        Node* pre = nullptr;
        // 为下层连接 next
        while (cur)
        {
            if (cur->left)
            {
                // 如果 pre 不为空，说明存在上一个需要连接的结点
                if (pre) pre->next = cur->left;
                pre = cur->left;
            }
            if (cur->right)
            {
                if (pre) pre->next = cur->right;
                pre = cur->right;
            }

            cur = cur->next;
        }
		
        // 寻找下层起始结点
        while (level)
        {
            if (level->left)
            {
                level = level->left;
                break;
            }

            if (level->right)
            {
                level = level->right;
                break;
            }
			
            // 当前结点左右为空，则寻找 next 的左右结点
            level = level->next;
        }
    }

    return root;
}
```

#### 引入 dummy 结点

```cpp
Node* connect(Node* root)
{
    if (!root) return nullptr;

    Node* cur = root;
    Node* dummy = new Node(0);

    while (cur)
    {
        // dummy 每层开始必须置为空防止无限循环最后一层
        dummy->next = nullptr;
        Node* pre = dummy;

        while (cur)
        {
            if (cur->left)
            {
                pre->next = cur->left;
                pre = pre->next;
            }
            if (cur->right)
            {
                pre->next = cur->right;
                pre = pre->next;
            }

            cur = cur->next;
        }

        cur = dummy->next;
    }

    return root;
}
```

